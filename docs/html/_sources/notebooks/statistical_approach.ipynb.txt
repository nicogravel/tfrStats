{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "j_Q6VK26-3j0"
      },
      "source": [
        "# <span style=\"color:#3498db\">**A mini-tutorial**</span>\n",
        "\n",
        "This codebook is a simple example meant to illustrate a two fundamental questions in time frequency analysis: 1) permutation-based null hypothesis testing and 2) correction for multiple comparisons. Typically, there is more than one approach for a given scenario. They will all depend on the dimensions of the data at hand, be these spatial locations, time and frequency analysis parameters, trials of different conditions, the nature of hypothesis, etc. For basic pedagogical purposes, here I focus on spectral power increases relative to baseline using two variants of the same method: 1) null hypothesis testing using the traditional min-max distribution approach, which captures variations at the extremes of the null ditribution, and 2) null hypthesis testing using the whole null distribution, obtained by averaging across specific dimensions. I invite the reader to audit the code and propvide feedback and comments in the open discussion subsection within the background section. Since there are several ways to achieve these goals and many realizations of these and other related methods (i.e. thresholds may be obtaind from the percentiles of the null distribution directly and further corrected in equivalent ways, or the pooling of data accomplished among specific dimensions), here I focus on two common methods using very simple examples in the hope to help those researchers (including myself) that are or may be in need of clarity on these matters, touch ground. Beware there may even be error to be spot or loops to optimize. \n",
        "\n",
        "Depending on the approach, the computation of the p-values will change slightly. In the min-max approach the minimum and maximum values at each permutations are used. When testing using the whole null distribution, the null values obtained from the permutations are averaged the same way the empirical distribution is averaged so the dimensions of the empirical distributions are preserved in the null distribution. Once the null distributions have been obtained, p-values are obtained using the empirical cumulative distribution method. Additionally, an optional step is illustrated in which cluster correction of the p-values is implemented. Provided the right Python environment is installed and data, this Jupyter notebook should work as a simple mini-tutorial and support the discussion of these and related basic approaches for computing TFRs and assessing their statistical significance in a clear way. The functions within this notebook are provided in an exploratory state and are subject to change. A background section with an open discussion subsection is included. Please feel free to use it help improve the codebook. Optionally, the package can be downloaded from here: https://github.com/nicogravel/tfrStats\n",
        "\n",
        "\n",
        "The statistical map of p-values  obtained using min-max seems to miss spectral and spatial detail. This leads to an overestimation of significance thresholds. While the cluster correction seems to partially remediate this, using the entire null-distribution provides more spectral and spatial detail to start to start with, making the cluster correction optional. \n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Installl the package\n",
        "\n",
        "Or run the last cell in the notebook.\n",
        "\n",
        "\n",
        "To run the [notebook](https://github.com/nicogravel/tfrStats/blob/main/docs/html/notebooks/statistical_approach.ipynb), clone the package locally (optionally forking it first) and then install it:\n",
        "  \n",
        "    \n",
        "```\n",
        "git clone https://github.com/nicogravel/tfrStats.git\n",
        "\n",
        "cd tfrStats\n",
        "\n",
        "pip install -e .\n",
        "```\n",
        "  \n",
        "    \n",
        "    \n",
        "\n",
        "Voilà!"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "cuKdKsiT-xLD"
      },
      "source": [
        "## Import libraries and define functions"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "id": "oYM2uHdeg2RH"
      },
      "outputs": [],
      "source": [
        "from tfrStats.plot_tfr_stats import plot_tfr_stats as plot_tfr_stats\n",
        "from tfrStats.plot_dtfr_stats import plot_dtfr_stats as plot_dtfr_stats\n",
        "\n",
        "\n",
        "in_path   = '/Volumes/Gandalf/MWlamprop/data/'\n",
        "out_path  = '/Volumes/Gandalf/MWlamprop/results/stats/univariate/'"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Compute p-values\n",
        "\n",
        "Here we plot TFRs with the significance threshold computed from p-values (i.e. p-val <= 0.05) (top panel, blue trace). The alpha mask specifies the section containing the values above the null percentile cutoff (i.e. 95%). The p-values (bottom panel) with the null percentile cutoff  (red trace)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### min-max"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "/Volumes/Gandalf/MWlamprop/results/stats/univariate/uvtfr_stats_high_grat_spw_1000_minmax.npz\n",
            "tfr emp  :  (30, 12, 16, 113)\n",
            "tfr null    (1000, 30, 12, 16, 2)\n",
            "(16, 113)\n",
            "hola: (1000, 16, 2)\n",
            "(16, 113)\n",
            "min = 21.35240269384813 max = 95.0319842368204\n"
          ]
        },
        {
          "ename": "UnboundLocalError",
          "evalue": "local variable 'coloroffset' referenced before assignment",
          "output_type": "error",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mUnboundLocalError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[1;32m/Users/nicogravel/Documents/Websites/tfrStats/tfrStats_local/docs/source/notebooks/statistical_approach.ipynb Cell 7\u001b[0m line \u001b[0;36m9\n\u001b[1;32m      <a href='vscode-notebook-cell:/Users/nicogravel/Documents/Websites/tfrStats/tfrStats_local/docs/source/notebooks/statistical_approach.ipynb#W6sZmlsZQ%3D%3D?line=5'>6</a>\u001b[0m cond         \u001b[39m=\u001b[39m \u001b[39m0\u001b[39m\n\u001b[1;32m      <a href='vscode-notebook-cell:/Users/nicogravel/Documents/Websites/tfrStats/tfrStats_local/docs/source/notebooks/statistical_approach.ipynb#W6sZmlsZQ%3D%3D?line=6'>7</a>\u001b[0m \u001b[39mtype\u001b[39m         \u001b[39m=\u001b[39m \u001b[39m'\u001b[39m\u001b[39mminmax\u001b[39m\u001b[39m'\u001b[39m\n\u001b[0;32m----> <a href='vscode-notebook-cell:/Users/nicogravel/Documents/Websites/tfrStats/tfrStats_local/docs/source/notebooks/statistical_approach.ipynb#W6sZmlsZQ%3D%3D?line=8'>9</a>\u001b[0m plot_tfr_stats(out_path, cond, fband, null, correction, cluster_size, \u001b[39mtype\u001b[39m, alpha)\n",
            "File \u001b[0;32m~/Documents/Websites/tfrStats/tfrStats_local/tfrStats/plot_tfr_stats.py:127\u001b[0m, in \u001b[0;36mplot_tfr_stats\u001b[0;34m(input_path, cond, fband, null, correction, cluster_size, type, alpha)\u001b[0m\n\u001b[1;32m    125\u001b[0m     vmin \u001b[39m=\u001b[39m _min\n\u001b[1;32m    126\u001b[0m     vmax \u001b[39m=\u001b[39m _max\n\u001b[0;32m--> 127\u001b[0m vcenter \u001b[39m=\u001b[39m coloroffset(vmin, vmax, coloff)\n\u001b[1;32m    128\u001b[0m norm \u001b[39m=\u001b[39m colors\u001b[39m.\u001b[39mTwoSlopeNorm(vmin\u001b[39m=\u001b[39mvmin, vcenter\u001b[39m=\u001b[39mvcenter, vmax\u001b[39m=\u001b[39mvmax)\n\u001b[1;32m    129\u001b[0m TFR_emp \u001b[39m=\u001b[39m f(x2, y2)\n",
            "\u001b[0;31mUnboundLocalError\u001b[0m: local variable 'coloroffset' referenced before assignment"
          ]
        },
        {
          "data": {
            "image/png": "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",
            "text/plain": [
              "<Figure size 600x400 with 2 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "null         = [1, 95]\n",
        "alpha        = 0.01\n",
        "correction   = 1\n",
        "cluster_size = 0\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'minmax'\n",
        "\n",
        "plot_tfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### whole-null"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [0, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.01\n",
        "correction   = 1\n",
        "cluster_size = 0\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'whole'\n",
        "\n",
        "plot_tfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Cluster correction of time-frequency bins\n",
        "\n",
        "\n",
        "One can apply cluster correction either to the percetniles (using only this correction in a single step), or to the or pvalues (turning it into a second, optional step). Here we compute distances between all time-frequency bins, pool p-vals of neighbouring time-frequency bins based on a distance threshold (defined by cluster size), test if a time-frequency bin and its neighbours are below alpha, and —if true, average the p-values within the cluster and assign the resulting average as acorrected p-value to the time-frequency bin."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### min-max"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [1, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.01\n",
        "correction   = 2\n",
        "cluster_size = 3\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'minmax'\n",
        "\n",
        "plot_tfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### whole-null"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [0, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.01\n",
        "correction   = 2\n",
        "cluster_size = 2\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'whole'\n",
        "\n",
        "plot_tfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##  Spectral power as a function of depth and space\n",
        "\n",
        "For this other type of TFR one must consider the pooling of data over predefined frequency bins, as well as spatial dimentions (i.e.  ROIs). Therefore, the multiple correction will change slightly. "
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### min-max"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [1, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.05\n",
        "correction   = 1\n",
        "cluster_size = 0\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'minmax'\n",
        "\n",
        "plot_dtfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "###  whole null"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [0, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.05\n",
        "correction   = 1\n",
        "cluster_size = 0\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'whole'\n",
        "\n",
        "plot_dtfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Cluster correction of space-frequency bins\n",
        "\n",
        "\n",
        "One can apply cluster correction either to the percetniles (using only this correction in a single step), or to the or pvalues (turning it into a second, optional step). Here we compute distances between all space-frequency bins, pool p-vals of neighbouring space-frequency bins based on a distance threshold (defined by cluster size), test if a space-frequency bin and its neighbours are below alpha, and —if true, average the p-values within the cluster and assign the resulting average as acorrected p-value to the space-frequency bin."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### min-max"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [1, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.05\n",
        "correction   = 2\n",
        "cluster_size = 1\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'minmax'\n",
        "\n",
        "plot_dtfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### whole-null"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "null         = [0, 95] #     results   = ['_100', '_100_minmax']\n",
        "alpha        = 0.05\n",
        "correction   = 2\n",
        "cluster_size = 1\n",
        "fband        = 1\n",
        "cond         = 0\n",
        "type         = 'whole'\n",
        "\n",
        "plot_dtfr_stats(out_path, cond, fband, null, correction, cluster_size, type, alpha)  # pick ther min-max results and turn them into p-values"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [
        "szKEE41WIZlD",
        "cuKdKsiT-xLD",
        "OWH7Fjfy_K5Q",
        "FFpTHYv8BYEw",
        "ZhUt1I13Bbfv",
        "dcOdfYWeBhYn",
        "-lRqU1vNBkEp"
      ],
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.13"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
